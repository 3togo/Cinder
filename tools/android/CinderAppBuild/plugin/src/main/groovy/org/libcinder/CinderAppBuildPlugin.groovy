package org.libcinder.gradle

import org.gradle.api.GradleException
import org.gradle.api.InvalidUserDataException
import org.gradle.api.Project
import org.gradle.api.Plugin
import org.gradle.api.tasks.*
import java.nio.file.Path;
import java.nio.file.Paths;

class CinderAppBuildPlugin implements Plugin<Project> {
    def mSourceFiles  = []
    def mIncludeDirs  = []
    def mSharedLibs   = []
    def mStaticLibs   = []
    def mStaticBlocks = []

    String relativePath( aBaseDir, aFilePath ) {
        Path baseDir  = Paths.get(aBaseDir);
        Path filePath = Paths.get(aFilePath);
        Path result = baseDir.relativize(filePath);
        return result.toString()
    }


    void parseSourceFiles(Project project, cppBuildDir) {
        this.mSourceFiles = []
        if( ! project.cinder.srcDirs.empty ) {
            this.mSourceFiles.add("\\")
            project.cinder.srcDirs.each {
                def dir = new File("${project.projectDir}/" + it)                                       
                dir.eachFile() {
                    String path = it.canonicalPath.toString()                    
                    if( ! path.startsWith( "." ) ) {
                        String relPath = this.relativePath( cppBuildDir, path )
                        this.mSourceFiles.add("\t" + relPath + " \\")
                    }
                }

            }
        }
    }

    void parseIncludeDirs(Project project) {
        this.mIncludeDirs = []
        if( ! project.cinder.includeDirs.empty ) {
            this.mIncludeDirs.add("\\")
            project.cinder.includeDirs.each {
                String path = (new File("${project.projectDir}/" + it)).canonicalPath.toString()
                this.mIncludeDirs.add("\t" + path + " \\")
            }
        }
    }

    void parseSharedLibs(Project project) {
        this.mSharedLibs = []
        if( ! project.cinder.ldLibs.empty ) { 
            mSharedLibs.add("\\")
            project.cinder.ldLibs.each {
                mSharedLibs.add("\t" + "-l" + it + "\\")
            }
        }
    }

    void parseStaticLibs(Project project) {
        this.mStaticLibs = []
        this.mStaticBlocks = []
        if( ! project.cinder.staticLibs.empty ) {
            this.mStaticLibs.add("\\")
            project.cinder.staticLibs.each {
                String path = (new File(it)).canonicalPath.toString()

                // short name
                String shortName = path
                def lastSlashPos = shortName.lastIndexOf( "/" )
                if( -1 != lastSlashPos ) {
                    shortName = shortName.substring(lastSlashPos + 1, shortName.length())
                }
                shortName = shortName.replace(".a", "")
                this.mStaticLibs.add("\t" + shortName + " \\")


                this.mStaticBlocks.add("include \$(CLEAR_VARS)")
                this.mStaticBlocks.add("LOCAL_MODULE    := " + shortName)
                this.mStaticBlocks.add("LOCAL_SRC_FILES := " + path)
                this.mStaticBlocks.add("include \$(PREBUILT_STATIC_LIBRARY)")
                this.mStaticBlocks.add("")
            }
        }
    }

    void writeAndroidMk(Project project, String filePath) {
        def lines = []
        lines.add("# Generated by CinderAppBuildPlugin")
        lines.add("#")
        lines.add("LOCAL_PATH := \$(call my-dir)")
        lines.add("")           
        lines.add(this.mStaticBlocks.join("\n"))
        lines.add("# ------------------------------------------------------------------------------")
        lines.add("")
        lines.add("include \$(CLEAR_VARS)")
        lines.add("")
        lines.add("# Module Name" )
        lines.add("LOCAL_MODULE := ${project.cinder.moduleName}")
        lines.add("")
        lines.add("# C++ Source Files" )
        lines.add("LOCAL_SRC_FILES := "+ this.mSourceFiles.join("\n"))
        lines.add("")
        lines.add("# C++ Flags" )
        lines.add("LOCAL_CPPFLAGS += ${project.cinder.cppFlags}")
        lines.add("")
        lines.add("# Include Directories" )
        lines.add("LOCAL_C_INCLUDES := " + this.mIncludeDirs.join("\n"))
        lines.add("")
        lines.add("# Shared Libraries" )
        lines.add("LOCAL_LDLIBS := " + this.mSharedLibs.join("\n"))
        lines.add("")
        lines.add("# Static Libraries" )
        lines.add("LOCAL_STATIC_LIBRARIES := " + this.mStaticLibs.join("\n"))
        lines.add("")
        lines.add("include \$(BUILD_SHARED_LIBRARY)")
        lines.add("")
        lines.add("")
        
        def outFile = new File( "${filePath}" )
        outFile.text = lines.join("\n")

        if( outFile.exists() ) {
            println "Wrote ${filePath}"
        }
    }

    void ndkDirCheck(Project project) {
        File ndkDir = project.plugins.findPlugin('com.android.application').getNdkFolder()
        if( null == ndkDir ) {
            throw new InvalidUserDataException("ndk.dir is null! Make sure ndk.dir in local.properties is set.")
        }
        //
        if( ! ndkDir.exists() ) {
            throw new InvalidUserDataException("ndk.dir does not exist! (ndk.dir=" + ndkDir.toString()+")")
        }
    }

    String makeNdkArg(key, value) {
        String result = "${key}=${value}"
        return result
    }
    
    void apply(Project project) {
        project.extensions.create("cinder", CinderAppBuildPluginExtension)

        def projectDir = project.projectDir
        def buildDir = project.buildDir
        def buildType = 'unset' /// CHANGE TO: debug AFTER TESTING
        
        // Extract selected build type from app.iml
        def parsedXml = (new XmlSlurper()).parse("${project.projectDir}/app.iml")
        def nodes = parsedXml.depthFirst().findAll { it.name() == 'option' && it.@name == 'SELECTED_BUILD_VARIANT' }
        if( ! nodes.empty ) {
            buildType = nodes[0].@value
        }
       
        // TASK: cinderGenerateNdkBuild
        project.task('cinderGenerateNdkBuild') << {
            this.ndkDirCheck(project)

            def dirPath = "${buildDir}/cinder-ndk/${buildType}"
            def filePath = "${dirPath}/Android.mk" 
            def outDir  = new File( "${dirPath}" )
            if( ! outDir.exists() ) {
                outDir.mkdirs()
                println "Created ${dirPath}"
            }

            // Directory where cpp builds take place
            def cppBuildDir = (new File(filePath)).getParentFile().getCanonicalPath();

            // Parse
            try {
                this.parseSourceFiles(project, cppBuildDir)
            } catch( e ) {
                throw new GradleException("Source files parse failed, e=" + e)
            }
           
            this.parseIncludeDirs(project)
            this.parseSharedLibs(project)
            this.parseStaticLibs(project)

            // Write
            this.writeAndroidMk(project, filePath)
        }  

        // TASK: cinderCompileNdk
        project.task('cinderCompileNdk', dependsOn: 'cinderGenerateNdkBuild') << {
            this.ndkDirCheck(project)

            String ndkDir = project.plugins.findPlugin('com.android.application').getNdkFolder().toString()
            
            def ndkBuildCmd  = "${ndkDir}/ndk-build"
            def ndkBuildArgs = []
            
            if( project.cinder.verbose ) {
                ndkBuildArgs.add(this.makeNdkArg("V", "1"))
            }
            ndkBuildArgs.add(this.makeNdkArg("NDK_PROJECT_PATH", "null"))
            ndkBuildArgs.add(this.makeNdkArg("APP_BUILD_SCRIPT", "${buildDir}/cinder-ndk/debug/Android.mk"))
            ndkBuildArgs.add(this.makeNdkArg("APP_PLATFORM",     "android-21"))
            ndkBuildArgs.add(this.makeNdkArg("NDK_OUT",          "${buildDir}/cinder-ndk/debug/obj"))
            ndkBuildArgs.add(this.makeNdkArg("NDK_LIBS_OUT",     "${projectDir}/src/main/jniLibs"))            
            ndkBuildArgs.add(this.makeNdkArg("APP_STL",          "gnustl_static"))
            ndkBuildArgs.add(this.makeNdkArg("APP_ABI",          "armeabi-v7a"))
       
            if( project.cinder.verbose ) {
                def cwd = System.getProperty("user.dir")  
                def execStr = ndkBuildCmd + " " + ndkBuildArgs.join(" ")
                println "EXEC DIR: ${cwd}"
                println "EXEC CMD: ${execStr}"
            }
 
            project.exec {
                executable = ndkBuildCmd
                args = ndkBuildArgs
            }    
        }
    }
}

class CinderAppBuildPluginExtension {
    def verbose = false
    def moduleName = ""
    def srcDirs = []
    def cppFlags = ""
    def includeDirs = []
    def ldLibs = []
    def staticLibs = []
    def stl = "gnustl_static"
}

